name: Common .NET setup and build workflow

permissions:
  contents: read
  actions: write   # needed for the optional cleanup step at the end

on:
  workflow_call:
    inputs:
      configuration:
        type: string
        default: 'Release'
        description: 'Build configuration'

      dotnetVersions:
        type: string
        default: |
          8.0.x
          9.0.x
          10.0.x
        description: 'Newline-separated list of .NET SDKs'

      productNamespacePrefix:
        type: string
        required: true
        description: 'Namespace prefix for coverage include/exclude filters'

      useVisualStudioPreview:
        type: boolean
        default: false
        description: 'Use VS preview on Windows (for UNO/mobile scenarios)'

      solutionFile:
        type: string
        description: 'Solution file relative to srcFolder'
        
      srcFolder:
        type: string
        default: 'src'
        description: 'Folder containing the solution'

      performTests:
        type: boolean
        default: true
        description: 'Run tests + collect coverage on each OS'

      useNBGV:
        type: boolean
        default: true
        description: 'Run NBGV to stamp version variables'
        
      createArtifacts:
        type: boolean
        default: true
        description: 'Upload NuGet packages from Windows job'

      installWorkloads:
        type: boolean
        default: false
        description: 'If true, run workload restore (all OSes)'

      useUNO:
        type: boolean
        default: false
        description: 'Enable UNO-specific steps on Windows (msbuild/pack flow)'

      testsProjectGlob:
        type: string
        default: '**/*Tests*.csproj'
        description: 'Glob for test csproj files, relative to srcFolder'

      coverageFormats:
        type: string
        default: 'cobertura'
        description: 'Coverage output format (cobertura, xml, coverage)'

      testingMode:
        type: string
        default: 'auto'
        description: 'Testing mode: auto (detect), mtp (Microsoft Testing Platform), legacy (Coverlet)'

      mergedCoverageArtifactName:
        type: string
        default: 'coverage-all'
        description: 'Name of the artifact with all raw coverage reports'

      cleanupPerOsArtifacts:
        type: boolean
        default: true
        description: 'Delete the temporary per-OS artifacts after final upload'

      uploadCodecov:
        type: boolean
        default: true
        description: 'Upload coverage to Codecov in the collector job'

    secrets:
      NuGetAPIKey:
        required: false
      CODECOV_TOKEN:
        required: true

jobs:
  # ============================
  # WINDOWS (parallel)
  # ============================
  build-windows:
    runs-on: windows-latest
    env:
      DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE: 1
    outputs:
      nbgv: ${{ steps.nbgv.outputs.SemVer2 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          lfs: true

      - name: Setup .NET (with NuGet cache)
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnetVersions }}
          #dotnet-quality: 'preview'
          cache: true
          cache-dependency-path: |
            **/Directory.Packages.props
            **/*.sln
            **/*.csproj
            **/global.json
            **/nuget.config

      - name: Cache NuGet HTTP (v3)
        uses: actions/cache@v5
        with:
          path: |
            %LOCALAPPDATA%\NuGet\v3-cache        
          key: ${{ runner.os }}-nugetv3-${{ hashFiles('**/Directory.Packages.props', '**/*.sln', '**/*.csproj', '**/global.json', '**/nuget.config') }}
          restore-keys: |
            ${{ runner.os }}-nugetv3-

      - name: Get Latest Visual Studio Version
        if: inputs.useUNO == true
        shell: bash
        run: |
          echo "Downloading Visual Studio 2026 Insiders bootstrapper..."
          curl -L -o vs_enterprise.exe "https://aka.ms/vs/18/insider/vs_enterprise.exe"

          echo "Starting Visual Studio 2026 Insiders installation..."
          ./vs_enterprise.exe --wait \
            --add Microsoft.VisualStudio.Workload.NetCrossPlat \
            --add Microsoft.VisualStudio.Workload.ManagedDesktop \
            --add Microsoft.VisualStudio.Workload.Universal \
            --add Microsoft.VisualStudio.Workload.NetWeb \
            --quiet \
            --installPath "C:\Program Files\Microsoft Visual Studio\2026\Enterprise"

          echo "Visual Studio installation complete."

      - name: Restore .NET Workloads
        if: inputs.installWorkloads == true
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          if [ -n "${{ inputs.solutionFile }}" ]; then
            dotnet workload restore --skip-manifest-update --project "${{ inputs.solutionFile }}"
          else
            dotnet workload restore --skip-manifest-update
          fi

      - name: NBGV
        if: inputs.useNBGV == true
        id: nbgv
        uses: dotnet/nbgv@master
        with:
          setAllVars: true

      - name: NuGet Restore
        run: dotnet restore ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Add MSBuild to PATH (UNO)
        if: inputs.useUNO == true
        uses: microsoft/setup-msbuild@v2
        with:
          vs-prerelease: true

      - name: Build (msbuild)
        if: inputs.useUNO == true
        run: msbuild /t:build,pack /nowarn:MSB4011 /maxcpucount /p:NoPackageAnalysis=true /verbosity:minimal /p:Configuration=${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Build (dotnet)
        if: inputs.useUNO == false
        run: dotnet build --no-restore --configuration ${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Pack (dotnet)
        if: inputs.useUNO == false
        run: dotnet pack --no-restore --configuration ${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Detect Testing Mode
        if: inputs.performTests == true
        id: detect-mode
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          MODE="${{ inputs.testingMode }}"

          if [ "$MODE" == "auto" ]; then
            echo "ðŸ” Auto-detecting testing platform in ${{ inputs.srcFolder }}..."

            # Check for MTP indicator (the coverage package)
            if grep -r "Microsoft.Testing.Extensions.CodeCoverage" . --include="*.props" --include="*.targets" --include="*.csproj" > /dev/null 2>&1; then
              echo "âœ… MTP Package detected."

              # Enforce CLEAN BREAK: Native JSON config must exist in the source folder
              if [ -f "testconfig.json" ]; then
                MODE="mtp"
                echo "ðŸš€ Clean Break Mode: Found testconfig.json in ${{ inputs.srcFolder }}"
              else
                echo "âŒ ERROR: MTP detected but 'testconfig.json' is missing in ${{ inputs.srcFolder }}!"
                echo ""
                echo "Microsoft Best Practices for MTP require a 'testconfig.json' file to manage coverage and execution."
                echo "This native JSON configuration eliminates CLI switch errors (MSB1001) and ensures local/CI parity."
                echo ""
                echo "Create ${{ inputs.srcFolder }}/testconfig.json with coverage settings:"
                echo "https://learn.microsoft.com/en-us/dotnet/core/testing/microsoft-testing-platform-extensions-code-coverage"
                exit 1
              fi
            else
              MODE="legacy"
              echo "âš ï¸  No MTP indicators found - falling back to legacy Coverlet"
            fi
          fi

          echo "mode=$MODE" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Testing mode: $MODE"

      - name: Tests + Coverage (MTP)
        if: inputs.performTests == true && steps.detect-mode.outputs.mode == 'mtp'
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          dotnet test --solution ${{ inputs.solutionFile }} \
            --no-build \
            --configuration ${{ inputs.configuration }} \
            --coverage \
            --coverage-output-format cobertura \
            --results-directory ./TestResults

      - name: Tests + Coverage (Legacy Coverlet)
        if: inputs.performTests == true && steps.detect-mode.outputs.mode == 'legacy'
        uses: glennawatson/coverlet-msbuild@v2.1
        with:
          project-files: '${{ inputs.srcFolder }}/${{ inputs.testsProjectGlob }}'
          no-build: true
          exclude-filter: '[${{inputs.productNamespacePrefix}}.*.Tests.*]*,[${{inputs.productNamespacePrefix}}.Tests]*,[${{inputs.productNamespacePrefix}}.TestRunner.*]*'
          include-filter: '[${{inputs.productNamespacePrefix}}*]*'
          output-format: '"${{ inputs.coverageFormats }}"'
          configuration: ${{ inputs.configuration }}

      - name: Upload per-OS coverage (Windows â†’ temp)
        if: inputs.performTests == true
        uses: actions/upload-artifact@v6
        with:
          name: tmp-coverage-${{ runner.os }}
          path: |
            ${{ inputs.srcFolder }}/**/coverage.cobertura.xml
            ${{ inputs.srcFolder }}/**/coverage*.cobertura.xml
            ${{ inputs.srcFolder }}/**/TestResults/**/*.cobertura.xml
          if-no-files-found: warn
          retention-days: 3

      - name: Upload NuGet Packages
        if: inputs.createArtifacts == true
        uses: actions/upload-artifact@v6
        with:
          name: nuget
          path: '**/*.nupkg'
          if-no-files-found: warn

  # ============================
  # LINUX & MACOS (parallel matrix)
  # ============================
  build-unix:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        include:
          - os: macos-latest
            restore-prefix: sudo
          - os: ubuntu-latest
            restore-prefix: ''
    env:
      DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup .NET (with NuGet cache)
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnetVersions }}
          cache: true
          cache-dependency-path: |
            **/Directory.Packages.props
            **/*.sln
            **/*.csproj
            **/global.json
            **/nuget.config

      - name: Cache NuGet HTTP (v3)
        uses: actions/cache@v5
        with:
          path: ~/.local/share/NuGet/v3-cache
          key: ${{ runner.os }}-nugetv3-${{ hashFiles('**/Directory.Packages.props', '**/*.sln', '**/*.csproj', '**/global.json', '**/nuget.config') }}
          restore-keys: |
            ${{ runner.os }}-nugetv3-

      - name: Restore .NET Workloads
        if: inputs.installWorkloads == true
        working-directory: ${{ inputs.srcFolder }}
        run: |
          if [ -n "${{ inputs.solutionFile }}" ]; then
            ${{ matrix.restore-prefix }} dotnet workload restore --skip-manifest-update --project "${{ inputs.solutionFile }}"
          else
            ${{ matrix.restore-prefix }} dotnet workload restore --skip-manifest-update
          fi

      - name: Restore
        run: dotnet restore ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Build
        run: dotnet build --no-restore --configuration ${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Detect Testing Mode
        if: inputs.performTests == true
        id: detect-mode
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          MODE="${{ inputs.testingMode }}"

          if [ "$MODE" == "auto" ]; then
            echo "ðŸ” Auto-detecting testing platform in ${{ inputs.srcFolder }}..."

            # Check for MTP indicator (the coverage package)
            if grep -r "Microsoft.Testing.Extensions.CodeCoverage" . --include="*.props" --include="*.targets" --include="*.csproj" > /dev/null 2>&1; then
              echo "âœ… MTP Package detected."

              # Enforce CLEAN BREAK: Native JSON config must exist in the source folder
              if [ -f "testconfig.json" ]; then
                MODE="mtp"
                echo "ðŸš€ Clean Break Mode: Found testconfig.json in ${{ inputs.srcFolder }}"
              else
                echo "âŒ ERROR: MTP detected but 'testconfig.json' is missing in ${{ inputs.srcFolder }}!"
                echo ""
                echo "Microsoft Best Practices for MTP require a 'testconfig.json' file to manage coverage and execution."
                echo "This native JSON configuration eliminates CLI switch errors (MSB1001) and ensures local/CI parity."
                echo ""
                echo "Create ${{ inputs.srcFolder }}/testconfig.json with coverage settings:"
                echo "https://learn.microsoft.com/en-us/dotnet/core/testing/microsoft-testing-platform-extensions-code-coverage"
                exit 1
              fi
            else
              MODE="legacy"
              echo "âš ï¸  No MTP indicators found - falling back to legacy Coverlet"
            fi
          fi

          echo "mode=$MODE" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Testing mode: $MODE"

      - name: Tests + Coverage (MTP)
        if: inputs.performTests == true && steps.detect-mode.outputs.mode == 'mtp'
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          dotnet test --solution ${{ inputs.solutionFile }} \
            --no-build \
            --configuration ${{ inputs.configuration }} \
            --coverage \
            --coverage-output-format cobertura \
            --results-directory ./TestResults

      - name: Tests + Coverage (Legacy Coverlet)
        if: inputs.performTests == true && steps.detect-mode.outputs.mode == 'legacy'
        uses: glennawatson/coverlet-msbuild@v2.1
        with:
          project-files: '${{ inputs.srcFolder }}/${{ inputs.testsProjectGlob }}'
          no-build: true
          exclude-filter: '[${{inputs.productNamespacePrefix}}.*.Tests.*]*,[${{inputs.productNamespacePrefix}}.Tests]*,[${{inputs.productNamespacePrefix}}.TestRunner.*]*'
          include-filter: '[${{inputs.productNamespacePrefix}}*]*'
          output-format: '"${{ inputs.coverageFormats }}"'
          configuration: ${{ inputs.configuration }}

      - name: Upload per-OS coverage (temp)
        if: inputs.performTests == true
        uses: actions/upload-artifact@v6
        with:
          name: tmp-coverage-${{ runner.os }}
          path: |
            ${{ inputs.srcFolder }}/**/coverage.cobertura.xml
            ${{ inputs.srcFolder }}/**/coverage*.cobertura.xml
            ${{ inputs.srcFolder }}/**/TestResults/**/*.cobertura.xml
          if-no-files-found: warn
          retention-days: 3

  # ============================
  # COLLECTOR (waits for all) â€” uploads once + Codecov
  # ============================
  collect-coverage:
    needs:
      - build-windows
      - build-unix
    if: inputs.performTests == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (for PR summary context)
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download temp coverage artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: tmp-coverage-*
          path: ./.collect

      - name: Upload raw coverage reports (for debugging)
        uses: actions/upload-artifact@v6
        with:
          name: ${{ inputs.mergedCoverageArtifactName }}
          path: ./.collect
          if-no-files-found: warn
          retention-days: 30

      - name: Install and Upload to Codecov
        if: inputs.uploadCodecov == true && (github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false)
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        run: |
          pip install codecov-cli
          codecov-cli upload-coverage -s './.collect' --fail-on-error
          
      - name: Cleanup per-OS temp artifacts
        continue-on-error: true
        if: inputs.cleanupPerOsArtifacts == true
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          for name in tmp-coverage-windows tmp-coverage-Linux tmp-coverage-macOS; do
            id=$(gh api repos/$REPO/actions/artifacts --paginate --jq ".artifacts[] | select(.name==\"$name\") | .id" | head -n1)
            if [ -n "$id" ]; then
              gh api -X DELETE repos/$REPO/actions/artifacts/$id
              echo "Deleted $name (id $id)"
            else
              echo "No artifact named $name found to delete."
            fi
          done
