# .github/workflows/common-dotnet-build.yml
name: Common .NET setup and build workflow

permissions:
  contents: read
  actions: write   # needed for the optional cleanup step at the end

on:
  workflow_call:
    inputs:
      configuration:
        type: string
        default: 'Release'
        description: 'Build configuration'

      dotnetVersions:
        type: string
        default: |
          8.0.x
          9.0.x
        description: 'Newline-separated list of .NET SDKs'

      productNamespacePrefix:
        type: string
        required: true
        description: 'Namespace prefix for coverage include/exclude filters'

      useVisualStudioPreview:
        type: boolean
        default: false
        description: 'Use VS preview on Windows (for UNO/mobile scenarios)'

      solutionFile:
        type: string
        description: 'Solution file relative to srcFolder'
        
      srcFolder:
        type: string
        default: 'src'
        description: 'Folder containing the solution'

      performTests:
        type: boolean
        default: true
        description: 'Run tests + collect coverage on each OS'

      useNBGV:
        type: boolean
        default: true
        description: 'Run NBGV to stamp version variables'
        
      createArtifacts:
        type: boolean
        default: true
        description: 'Upload NuGet packages from Windows job'

      # If true, run `dotnet workload restore` (with --skip-manifest-update) on each OS.
      installWorkloads:
        type: boolean
        default: false
        description: 'If true, run workload restore (all OSes)'

      # Install Tizen workload via Samsung script (Windows/macOS only).
      installTizenWorkload:
        type: boolean
        default: true
        description: 'If true, install Tizen workload (Windows/macOS) using Samsung script'

      useUNO:
        type: boolean
        default: false
        description: 'Enable UNO-specific steps on Windows (msbuild/pack flow)'

      testsProjectGlob:
        type: string
        default: '**/*Tests*.csproj'
        description: 'Glob for test csproj files, relative to srcFolder'

      coverageFormats:
        type: string
        default: 'opencover,cobertura'
        description: 'Coverlet formats to output'

      coverageReportTypes:
        type: string
        default: 'HtmlInline_AzurePipelines;MarkdownSummary_GitHub'
        description: 'ReportGenerator report types (used for merged report)'

      mergedCoverageArtifactName:
        type: string
        default: 'coverage-all'
        description: 'Name of the single final artifact with all coverage'

      mergeCoverage:
        type: boolean
        default: true
        description: 'Merge Cobertura reports from all OSes into one HTML+summary'

      cleanupPerOsArtifacts:
        type: boolean
        default: true
        description: 'Delete the temporary per-OS artifacts after final upload'

      uploadCodecov:
        type: boolean
        default: true
        description: 'Upload coverage to Codecov in the collector job'

      codecovFlags:
        type: string
        default: ''
        description: 'Optional Codecov flags (comma-separated) for the upload'

      codecovName:
        type: string
        default: 'combined'
        description: 'Optional Codecov upload name'

    secrets:
      NuGetAPIKey:
        required: false
      CODECOV_TOKEN:
        required: true

jobs:
  # ============================
  # WINDOWS (parallel)
  # ============================
  build-windows:
    runs-on: windows-latest
    env:
      DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE: 1
    outputs:
      nbgv: ${{ steps.nbgv.outputs.SemVer2 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          lfs: true

      - name: Setup .NET (with NuGet cache)
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnetVersions }}
          cache: true
          cache-dependency-path: |
            **/Directory.Packages.props
            **/*.sln
            **/*.csproj
            **/global.json
            **/nuget.config

      - name: Cache NuGet HTTP (v3)
        uses: actions/cache@v4
        with:
          path: |
            ~\AppData\Local\NuGet\v3-cache
          key: ${{ runner.os }}-nugetv3-${{ hashFiles('**/Directory.Packages.props', '**/*.sln', '**/*.csproj', '**/global.json', '**/nuget.config') }}
          restore-keys: |
            ${{ runner.os }}-nugetv3-

      - name: Get Latest Visual Studio Version
        if: inputs.useVisualStudioPreview == true
        shell: bash
        run: |
          dotnet tool update -g dotnet-vs
          vs where release
          vs update release Enterprise
          vs modify release Enterprise +mobile +desktop +uwp +web
          vs where release

      # Install Tizen via Samsung script, pinned to the current SDK band (avoids MSI fetch).
      - name: Install Tizen workload (Windows)
        if: inputs.installTizenWorkload == true
        shell: pwsh
        run: |
          $dotver = & dotnet --version
          $p = $dotver.Split('.')
          $band = "$($p[0]).$($p[1]).$($p[2][0])00"
          Write-Host "Installing Tizen workload for SDK band $band"
          Invoke-WebRequest https://raw.githubusercontent.com/Samsung/Tizen.NET/main/workload/scripts/workload-install.ps1 -OutFile install-tizen.ps1
          # Let the script choose the right version for the band; no MSI path.
          .\install-tizen.ps1 -t $band

      # Only restore workloads when explicitly enabled, and never update manifests.
      - name: Restore .NET Workloads
        if: inputs.installWorkloads == true
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          if [ -n "${{ inputs.solutionFile }}" ]; then
            dotnet workload restore --skip-manifest-update --project "${{ inputs.solutionFile }}"
          else
            dotnet workload restore --skip-manifest-update
          fi

      - name: NBGV
        if: inputs.useNBGV == true
        id: nbgv
        uses: dotnet/nbgv@master
        with:
          setAllVars: true

      - name: Install NuGet (CLI)
        uses: nuget/setup-nuget@v2
        with:
          nuget-api-key: ${{ secrets.NuGetAPIKey }}
          nuget-version: '6.x'

      - name: NuGet Restore
        run: nuget restore ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Add MSBuild to PATH (UNO)
        if: inputs.useUNO == true
        uses: microsoft/setup-msbuild@v2
        with:
          vs-prerelease: true

      - name: Build (msbuild)
        if: inputs.useUNO == true
        run: msbuild /t:build,pack /nowarn:MSB4011 /maxcpucount /p:NoPackageAnalysis=true /verbosity:minimal /p:Configuration=${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Build (dotnet)
        if: inputs.useUNO == false
        run: dotnet build --no-restore --configuration ${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Pack (dotnet)
        if: inputs.useUNO == false
        run: dotnet pack --no-restore --configuration ${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      # ---- Tests + Coverage
      - name: Tests + Coverage (Windows)
        if: inputs.performTests == true
        uses: glennawatson/coverlet-msbuild@v2.1
        with:
          project-files: '${{ inputs.srcFolder }}/${{ inputs.testsProjectGlob }}'
          no-build: true
          exclude-filter: '[${{inputs.productNamespacePrefix}}.*.Tests.*]*,[${{inputs.productNamespacePrefix}}.Tests]*,[${{inputs.productNamespacePrefix}}.TestRunner.*]*'
          include-filter: '[${{inputs.productNamespacePrefix}}*]*'
          output-format: '"${{ inputs.coverageFormats }}"'
          configuration: ${{ inputs.configuration }}

      # temp artifact used only for the collector job
      - name: Upload per-OS coverage (Windows → temp)
        if: inputs.performTests == true
        uses: actions/upload-artifact@v4
        with:
          name: tmp-coverage-windows
          path: |
            ${{ inputs.srcFolder }}/**/coverage.opencover.xml
            ${{ inputs.srcFolder }}/**/coverage.cobertura.xml
          if-no-files-found: warn
          retention-days: 3

      - name: Upload NuGet Packages
        if: inputs.createArtifacts == true
        uses: actions/upload-artifact@v4
        with:
          name: nuget
          path: '**/*.nupkg'
          if-no-files-found: warn

  # ============================
  # LINUX (parallel)
  # ============================
  build-linux:
    runs-on: ubuntu-latest
    env:
      DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup .NET (with NuGet cache)
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnetVersions }}
          cache: true
          cache-dependency-path: |
            **/Directory.Packages.props
            **/*.sln
            **/*.csproj
            **/global.json
            **/nuget.config

      - name: Cache NuGet HTTP (v3)
        uses: actions/cache@v4
        with:
          path: ~/.local/share/NuGet/v3-cache
          key: ${{ runner.os }}-nugetv3-${{ hashFiles('**/Directory.Packages.props', '**/*.sln', '**/*.csproj', '**/global.json', '**/nuget.config') }}
          restore-keys: |
            ${{ runner.os }}-nugetv3-

      # Workload restore only when enabled (no Tizen on Linux)
      - name: Restore .NET Workloads
        if: inputs.installWorkloads == true
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          if [ -n "${{ inputs.solutionFile }}" ]; then
            dotnet workload restore --skip-manifest-update --project "${{ inputs.solutionFile }}"
          else
            dotnet workload restore --skip-manifest-update
          fi

      - name: Restore
        run: dotnet restore ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Build
        run: dotnet build --no-restore --configuration ${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Tests + Coverage (Linux)
        if: inputs.performTests == true
        uses: glennawatson/coverlet-msbuild@v2.1
        with:
          project-files: '${{ inputs.srcFolder }}/${{ inputs.testsProjectGlob }}'
          no-build: true
          exclude-filter: '[${{inputs.productNamespacePrefix}}.*.Tests.*]*,[${{inputs.productNamespacePrefix}}.Tests]*,[${{inputs.productNamespacePrefix}}.TestRunner.*]*'
          include-filter: '[${{inputs.productNamespacePrefix}}*]*'
          output-format: '"${{ inputs.coverageFormats }}"'
          configuration: ${{ inputs.configuration }}

      - name: Upload per-OS coverage (Linux → temp)
        if: inputs.performTests == true
        uses: actions/upload-artifact@v4
        with:
          name: tmp-coverage-linux
          path: |
            ${{ inputs.srcFolder }}/**/coverage.opencover.xml
            ${{ inputs.srcFolder }}/**/coverage.cobertura.xml
          if-no-files-found: warn
          retention-days: 3

  # ============================
  # macOS (parallel)
  # ============================
  build-macos:
    runs-on: macos-latest
    env:
      DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup .NET (with NuGet cache)
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnetVersions }}
          cache: true
          cache-dependency-path: |
            **/Directory.Packages.props
            **/*.sln
            **/*.csproj
            **/global.json
            **/nuget.config

      - name: Cache NuGet HTTP (v3)
        uses: actions/cache@v4
        with:
          path: ~/.local/share/NuGet/v3-cache
          key: ${{ runner.os }}-nugetv3-${{ hashFiles('**/Directory.Packages.props', '**/*.sln', '**/*.csproj', '**/global.json', '**/nuget.config') }}
          restore-keys: |
            ${{ runner.os }}-nugetv3-

      # Install Tizen via Samsung script (macOS), pinned to current SDK band.
      - name: Install Tizen workload (macOS)
        if: inputs.installTizenWorkload == true
        shell: bash
        run: |
          DOTVER="$(dotnet --version)"
          IFS='.' read -r MA MI PA <<< "$DOTVER"
          BAND="${MA}.${MI}.${PA:0:1}00"
          echo "Installing Tizen workload for SDK band ${BAND}"
          curl -sSL https://raw.githubusercontent.com/Samsung/Tizen.NET/main/workload/scripts/workload-install.sh -o install-tizen.sh
          chmod +x install-tizen.sh
          # Script installs manifest/packs directly; avoid MSI path.
          sudo bash ./install-tizen.sh -t "${BAND}"

      # Workload restore only when enabled; use sudo to avoid permissions error; never update manifests.
      - name: Restore .NET Workloads
        if: inputs.installWorkloads == true
        shell: bash
        working-directory: ${{ inputs.srcFolder }}
        run: |
          if [ -n "${{ inputs.solutionFile }}" ]; then
            sudo dotnet workload restore --skip-manifest-update --project "${{ inputs.solutionFile }}"
          else
            sudo dotnet workload restore --skip-manifest-update
          fi

      - name: Restore
        run: dotnet restore ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Build
        run: dotnet build --no-restore --configuration ${{ inputs.configuration }} ${{ inputs.solutionFile }}
        working-directory: ${{ inputs.srcFolder }}

      - name: Tests + Coverage (macOS)
        if: inputs.performTests == true
        uses: glennawatson/coverlet-msbuild@v2.1
        with:
          project-files: '${{ inputs.srcFolder }}/${{ inputs.testsProjectGlob }}'
          no-build: true
          exclude-filter: '[${{inputs.productNamespacePrefix}}.*.Tests.*]*,[${{inputs.productNamespacePrefix}}.Tests]*,[${{inputs.productNamespacePrefix}}.TestRunner.*]*'
          include-filter: '[${{inputs.productNamespacePrefix}}*]*'
          output-format: '"${{ inputs.coverageFormats }}"'
          configuration: ${{ inputs.configuration }}

      - name: Upload per-OS coverage (macOS → temp)
        if: inputs.performTests == true
        uses: actions/upload-artifact@v4
        with:
          name: tmp-coverage-macos
          path: |
            ${{ inputs.srcFolder }}/**/coverage.opencover.xml
            ${{ inputs.srcFolder }}/**/coverage.cobertura.xml
          if-no-files-found: warn
          retention-days: 3

  # ============================
  # COLLECTOR (waits for all 3) — uploads once + Codecov
  # ============================
  collect-coverage:
    needs:
      - build-windows
      - build-linux
      - build-macos
    if: inputs.performTests == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (for PR summary context)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download temp coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: tmp-coverage-*
          path: ./.collect
          merge-multiple: true

      - name: Install ReportGenerator (for merged report)
        if: inputs.mergeCoverage == true
        run: dotnet tool install -g dotnet-reportgenerator-globaltool

      - name: Merge & Generate HTML + Summary
        if: inputs.mergeCoverage == true
        shell: bash
        run: |
          mkdir -p ./.artifacts/coverage-merged
          reportgenerator \
            -reports:"./.collect/**/coverage.cobertura.xml" \
            -targetdir:"./.artifacts/coverage-merged" \
            -reporttypes:"${{ inputs.coverageReportTypes }}"
          if [ -f "./.artifacts/coverage-merged/SummaryGithub.md" ]; then
            echo "## Combined Coverage" >> "$GITHUB_STEP_SUMMARY"
            cat "./.artifacts/coverage-merged/SummaryGithub.md" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Upload single consolidated artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.mergedCoverageArtifactName }}
          path: |
            ./.collect/**/coverage.opencover.xml
            ./.collect/**/coverage.cobertura.xml
            ./.artifacts/coverage-merged/**
          if-no-files-found: warn
          retention-days: 30

      - name: Upload to Codecov
        if: inputs.uploadCodecov == true && (github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false)
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: |
            ./.collect/**/coverage.cobertura.xml
            ./.collect/**/coverage.opencover.xml
          flags: ${{ inputs.codecovFlags }}
          name: ${{ inputs.codecovName }}
          disable_search: true
          fail_ci_if_error: true

      # Optional: delete temp per-OS artifacts so only the consolidated one remains
      - name: Cleanup per-OS temp artifacts
        if: inputs.cleanupPerOsArtifacts == true
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          for name in tmp-coverage-windows tmp-coverage-linux tmp-coverage-macos; do
            id=$(gh api repos/$REPO/actions/artifacts --paginate --jq ".artifacts[] | select(.name==\"$name\") | .id" | head -n1)
            if [ -n "$id" ]; then
              gh api -X DELETE repos/$REPO/actions/artifacts/$id
              echo "Deleted $name (id $id)"
            else
              echo "No artifact named $name found to delete."
            fi
          done
